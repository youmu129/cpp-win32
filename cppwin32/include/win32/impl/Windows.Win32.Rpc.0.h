// WARNING: Please don't edit this file. It was generated by C++/Win32 v0.0.0.1

#ifndef WIN32_Windows_Win32_Rpc_0_H
#define WIN32_Windows_Win32_Rpc_0_H
WIN32_EXPORT namespace win32::Windows::Win32::Rpc
{
#pragma region enums
    enum class ExtendedErrorParamTypes : int32_t
    {
        eeptAnsiString = 1,
        eeptUnicodeString = 2,
        eeptLongVal = 3,
        eeptShortVal = 4,
        eeptPointerVal = 5,
        eeptNone = 6,
        eeptBinary = 7,
    };
    enum class IDL_CS_CONVERT : int32_t
    {
        IDL_CS_NO_CONVERT = 0,
        IDL_CS_IN_PLACE_CONVERT = 1,
        IDL_CS_NEW_BUFFER_CONVERT = 2,
    };
    enum class LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION : int32_t
    {
        MarshalDirectionMarshal = 0,
        MarshalDirectionUnmarshal = 1,
    };
    enum class MIDL_ES_CODE : int32_t
    {
        MES_ENCODE = 0,
        MES_DECODE = 1,
        MES_ENCODE_NDR64 = 2,
    };
    enum class MIDL_ES_HANDLE_STYLE : int32_t
    {
        MES_INCREMENTAL_HANDLE = 0,
        MES_FIXED_BUFFER_HANDLE = 1,
        MES_DYNAMIC_BUFFER_HANDLE = 2,
    };
    enum class PROXY_PHASE : int32_t
    {
        PROXY_CALCSIZE = 0,
        PROXY_GETBUFFER = 1,
        PROXY_MARSHAL = 2,
        PROXY_SENDRECEIVE = 3,
        PROXY_UNMARSHAL = 4,
    };
    enum class RPC_ADDRESS_CHANGE_TYPE : int32_t
    {
        PROTOCOL_NOT_LOADED = 1,
        PROTOCOL_LOADED = 2,
        PROTOCOL_ADDRESS_CHANGE = 3,
    };
    enum class RPC_ASYNC_EVENT : int32_t
    {
        RpcCallComplete = 0,
        RpcSendComplete = 1,
        RpcReceiveComplete = 2,
        RpcClientDisconnect = 3,
        RpcClientCancel = 4,
    };
    enum class RPC_HTTP_REDIRECTOR_STAGE : int32_t
    {
        RPCHTTP_RS_REDIRECT = 1,
        RPCHTTP_RS_ACCESS_1 = 2,
        RPCHTTP_RS_SESSION = 3,
        RPCHTTP_RS_ACCESS_2 = 4,
        RPCHTTP_RS_INTERFACE = 5,
    };
    enum class RPC_NOTIFICATIONS : int32_t
    {
        RpcNotificationCallNone = 0,
        RpcNotificationClientDisconnect = 1,
        RpcNotificationCallCancel = 2,
    };
    enum class RPC_NOTIFICATION_TYPES : int32_t
    {
        RpcNotificationTypeNone = 0,
        RpcNotificationTypeEvent = 1,
        RpcNotificationTypeApc = 2,
        RpcNotificationTypeIoc = 3,
        RpcNotificationTypeHwnd = 4,
        RpcNotificationTypeCallback = 5,
    };
    enum class RpcCallClientLocality : int32_t
    {
        rcclInvalid = 0,
        rcclLocal = 1,
        rcclRemote = 2,
        rcclClientUnknownLocality = 3,
    };
    enum class RpcCallType : int32_t
    {
        rctInvalid = 0,
        rctNormal = 1,
        rctTraining = 2,
        rctGuaranteed = 3,
    };
    enum class RpcLocalAddressFormat : int32_t
    {
        rlafInvalid = 0,
        rlafIPv4 = 1,
        rlafIPv6 = 2,
    };
    enum class RpcProxyPerfCounters : int32_t
    {
        RpcCurrentUniqueUser = 1,
        RpcBackEndConnectionAttempts = 2,
        RpcBackEndConnectionFailed = 3,
        RpcRequestsPerSecond = 4,
        RpcIncomingConnections = 5,
        RpcIncomingBandwidth = 6,
        RpcOutgoingBandwidth = 7,
        RpcAttemptedLbsDecisions = 8,
        RpcFailedLbsDecisions = 9,
        RpcAttemptedLbsMessages = 10,
        RpcFailedLbsMessages = 11,
        RpcLastCounter = 12,
    };
    enum class STUB_PHASE : int32_t
    {
        STUB_UNMARSHAL = 0,
        STUB_CALL_SERVER = 1,
        STUB_MARSHAL = 2,
        STUB_CALL_SERVER_NO_HRESULT = 3,
    };
    enum class USER_MARSHAL_CB_TYPE : int32_t
    {
        USER_MARSHAL_CB_BUFFER_SIZE = 0,
        USER_MARSHAL_CB_MARSHALL = 1,
        USER_MARSHAL_CB_UNMARSHALL = 2,
        USER_MARSHAL_CB_FREE = 3,
    };
    enum class XLAT_SIDE : int32_t
    {
        XLAT_SERVER = 1,
        XLAT_CLIENT = 2,
    };
    enum class system_handle_t : int32_t
    {
        SYSTEM_HANDLE_FILE = 0,
        SYSTEM_HANDLE_SEMAPHORE = 1,
        SYSTEM_HANDLE_EVENT = 2,
        SYSTEM_HANDLE_MUTEX = 3,
        SYSTEM_HANDLE_PROCESS = 4,
        SYSTEM_HANDLE_TOKEN = 5,
        SYSTEM_HANDLE_SECTION = 6,
        SYSTEM_HANDLE_REG_KEY = 7,
        SYSTEM_HANDLE_THREAD = 8,
        SYSTEM_HANDLE_COMPOSITION_OBJECT = 9,
        SYSTEM_HANDLE_SOCKET = 10,
        SYSTEM_HANDLE_JOB = 11,
        SYSTEM_HANDLE_PIPE = 12,
        SYSTEM_HANDLE_MAX = 12,
        SYSTEM_HANDLE_INVALID = 255,
    };
#pragma endregion enums

#pragma region forward_declarations
    struct ARRAY_INFO;
    struct BinaryParam;
    union CLIENT_CALL_RETURN;
    struct COMM_FAULT_OFFSETS;
    struct FULL_PTR_XLAT_TABLES;
    struct GENERIC_BINDING_ROUTINE_PAIR;
    struct I_RpcProxyCallbackInterface;
    struct MALLOC_FREE_STRUCT;
    struct MIDL_FORMAT_STRING;
    struct MIDL_INTERCEPTION_INFO;
    struct MIDL_INTERFACE_METHOD_PROPERTIES;
    struct MIDL_METHOD_PROPERTY;
    struct MIDL_METHOD_PROPERTY_MAP;
    struct MIDL_STUBLESS_PROXY_INFO;
    struct MIDL_STUB_DESC;
    struct MIDL_STUB_MESSAGE;
    struct MIDL_SYNTAX_INFO;
    struct MIDL_TYPE_PICKLING_INFO;
    struct MIDL_WINRT_TYPE_SERIALIZATION_INFO;
    struct NDR_ALLOC_ALL_NODES_CONTEXT;
    struct NDR_CS_ROUTINES;
    struct NDR_CS_SIZE_CONVERT_ROUTINES;
    struct NDR_EXPR_DESC;
    struct NDR_POINTER_QUEUE_STATE;
    struct NDR_SCONTEXT_1;
    struct NDR_USER_MARSHAL_INFO;
    struct NDR_USER_MARSHAL_INFO_LEVEL1;
    struct RDR_CALLOUT_STATE;
    union RPC_ASYNC_NOTIFICATION_INFO;
    struct RPC_ASYNC_STATE;
    struct RPC_BINDING_HANDLE_OPTIONS_V1;
    struct RPC_BINDING_HANDLE_SECURITY_V1_A;
    struct RPC_BINDING_HANDLE_SECURITY_V1_W;
    struct RPC_BINDING_HANDLE_TEMPLATE_V1_A;
    struct RPC_BINDING_HANDLE_TEMPLATE_V1_W;
    struct RPC_BINDING_VECTOR;
    struct RPC_CALL_ATTRIBUTES_V1_A;
    struct RPC_CALL_ATTRIBUTES_V1_W;
    struct RPC_CALL_ATTRIBUTES_V2_A;
    struct RPC_CALL_ATTRIBUTES_V2_W;
    struct RPC_CALL_ATTRIBUTES_V3_A;
    struct RPC_CALL_ATTRIBUTES_V3_W;
    struct RPC_CALL_LOCAL_ADDRESS_V1;
    struct RPC_CLIENT_INFORMATION1;
    struct RPC_CLIENT_INTERFACE;
    struct RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR;
    struct RPC_DISPATCH_TABLE;
    struct RPC_EE_INFO_PARAM;
    struct RPC_ENDPOINT_TEMPLATEA;
    struct RPC_ENDPOINT_TEMPLATEW;
    struct RPC_ERROR_ENUM_HANDLE;
    struct RPC_EXTENDED_ERROR_INFO;
    struct RPC_HTTP_TRANSPORT_CREDENTIALS_A;
    struct RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A;
    struct RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W;
    struct RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A;
    struct RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W;
    struct RPC_HTTP_TRANSPORT_CREDENTIALS_W;
    struct RPC_IF_ID;
    struct RPC_IF_ID_VECTOR;
    struct RPC_INTERFACE_TEMPLATEA;
    struct RPC_INTERFACE_TEMPLATEW;
    struct RPC_MESSAGE;
    struct RPC_POLICY;
    struct RPC_PROTSEQ_ENDPOINT;
    struct RPC_PROTSEQ_VECTORA;
    struct RPC_PROTSEQ_VECTORW;
    struct RPC_SECURITY_QOS;
    struct RPC_SECURITY_QOS_V2_A;
    struct RPC_SECURITY_QOS_V2_W;
    struct RPC_SECURITY_QOS_V3_A;
    struct RPC_SECURITY_QOS_V3_W;
    struct RPC_SECURITY_QOS_V4_A;
    struct RPC_SECURITY_QOS_V4_W;
    struct RPC_SECURITY_QOS_V5_A;
    struct RPC_SECURITY_QOS_V5_W;
    struct RPC_SEC_CONTEXT_KEY_INFO;
    struct RPC_SERVER_INTERFACE;
    struct RPC_STATS_VECTOR;
    struct RPC_SYNTAX_IDENTIFIER;
    struct RPC_TRANSFER_SYNTAX;
    struct RPC_VERSION;
    struct SCONTEXT_QUEUE;
    struct USER_MARSHAL_CB;
    struct USER_MARSHAL_ROUTINE_QUADRUPLE;
    struct UUID_VECTOR;
    struct XMIT_ROUTINE_QUINTUPLE;
    struct _MIDL_SERVER_INFO_;
    struct _NDR_ASYNC_MESSAGE;
    struct _NDR_CORRELATION_INFO;
    struct _NDR_PROC_CONTEXT;
    struct __AnonymousRecord_rpcndr_L275_C9;
    struct __GENERIC_BINDING_INFO;
#pragma endregion forward_declarations

#pragma region delegates
    using RPC_OBJECT_INQ_FN = void __stdcall(::win32::guid*, ::win32::guid*, int32_t*);
    using RPC_IF_CALLBACK_FN = int32_t __stdcall(void*, void*);
    using RPC_SECURITY_CALLBACK_FN = void __stdcall(void*);
    using RPC_NEW_HTTP_PROXY_CHANNEL = int32_t __stdcall(Windows::Win32::Rpc::RPC_HTTP_REDIRECTOR_STAGE, uint16_t*, uint16_t*, uint16_t*, uint16_t*, void*, void*, void*, void*, uint32_t, uint16_t**, uint16_t**);
    using RPC_HTTP_PROXY_FREE_STRING = void __stdcall(uint16_t*);
    using RPC_AUTH_KEY_RETRIEVAL_FN = void __stdcall(void*, uint16_t*, uint32_t, void**, int32_t*);
    using RPC_MGMT_AUTHORIZATION_FN = int32_t __stdcall(void*, uint32_t, int32_t*);
    using RPC_INTERFACE_GROUP_IDLE_CALLBACK_FN = void __stdcall(void*, void*, uint32_t);
    using RPC_FORWARD_FUNCTION = int32_t __stdcall(::win32::guid*, Windows::Win32::Rpc::RPC_VERSION*, ::win32::guid*, uint8_t*, void**);
    using RPC_ADDRESS_CHANGE_FN = void __stdcall(void*);
    using RPC_DISPATCH_FUNCTION = void __stdcall(Windows::Win32::Rpc::RPC_MESSAGE*);
    using PRPC_RUNDOWN = void __stdcall(void*);
    using RPCLT_PDU_FILTER_FUNC = void __stdcall(void*, uint32_t, int32_t);
    using RPC_SETFILTER_FUNC = void __stdcall(Windows::Win32::Rpc::RPCLT_PDU_FILTER_FUNC*);
    using RPC_BLOCKING_FN = int32_t __stdcall(void*, void*, void*);
    using I_RpcProxyIsValidMachineFn = int32_t __stdcall(uint16_t*, uint16_t*, uint32_t);
    using I_RpcProxyGetClientAddressFn = int32_t __stdcall(void*, int8_t*, uint32_t*);
    using I_RpcProxyGetConnectionTimeoutFn = int32_t __stdcall(uint32_t*);
    using I_RpcPerformCalloutFn = int32_t __stdcall(void*, Windows::Win32::Rpc::RDR_CALLOUT_STATE*, Windows::Win32::Rpc::RPC_HTTP_REDIRECTOR_STAGE);
    using I_RpcFreeCalloutStateFn = void __stdcall(Windows::Win32::Rpc::RDR_CALLOUT_STATE*);
    using I_RpcProxyGetClientSessionAndResourceUUID = int32_t __stdcall(void*, int32_t*, ::win32::guid*, int32_t*, ::win32::guid*);
    using I_RpcProxyFilterIfFn = int32_t __stdcall(void*, ::win32::guid*, uint16_t, int32_t*);
    using I_RpcProxyUpdatePerfCounterFn = void __stdcall(Windows::Win32::Rpc::RpcProxyPerfCounters, int32_t, uint32_t);
    using I_RpcProxyUpdatePerfCounterBackendServerFn = void __stdcall(uint16_t*, int32_t);
    using RPCNOTIFICATION_ROUTINE = void __stdcall(Windows::Win32::Rpc::RPC_ASYNC_STATE*, void*, Windows::Win32::Rpc::RPC_ASYNC_EVENT);
    using PFN_RPCNOTIFICATION_ROUTINE = void __stdcall();
    using NDR_RUNDOWN = void __stdcall(void*);
    using NDR_NOTIFY_ROUTINE = void __stdcall();
    using NDR_NOTIFY2_ROUTINE = void __stdcall(uint8_t);
    using EXPR_EVAL = void __stdcall(Windows::Win32::Rpc::MIDL_STUB_MESSAGE*);
    using GENERIC_BINDING_ROUTINE = void* __stdcall(void*);
    using GENERIC_UNBIND_ROUTINE = void __stdcall(void*, uint8_t*);
    using XMIT_HELPER_ROUTINE = void __stdcall(Windows::Win32::Rpc::MIDL_STUB_MESSAGE*);
    using USER_MARSHAL_SIZING_ROUTINE = uint32_t __stdcall(uint32_t*, uint32_t, void*);
    using USER_MARSHAL_MARSHALLING_ROUTINE = uint8_t* __stdcall(uint32_t*, uint8_t*, void*);
    using USER_MARSHAL_UNMARSHALLING_ROUTINE = uint8_t* __stdcall(uint32_t*, uint8_t*, void*);
    using USER_MARSHAL_FREEING_ROUTINE = void __stdcall(uint32_t*, void*);
    using CS_TYPE_NET_SIZE_ROUTINE = void __stdcall(void*, uint32_t, uint32_t, Windows::Win32::Rpc::IDL_CS_CONVERT*, uint32_t*, uint32_t*);
    using CS_TYPE_LOCAL_SIZE_ROUTINE = void __stdcall(void*, uint32_t, uint32_t, Windows::Win32::Rpc::IDL_CS_CONVERT*, uint32_t*, uint32_t*);
    using CS_TYPE_TO_NETCS_ROUTINE = void __stdcall(void*, uint32_t, void*, uint32_t, uint8_t*, uint32_t*, uint32_t*);
    using CS_TYPE_FROM_NETCS_ROUTINE = void __stdcall(void*, uint32_t, uint8_t*, uint32_t, uint32_t, void*, uint32_t*, uint32_t*);
    using CS_TAG_GETTING_ROUTINE = void __stdcall(void*, int32_t, uint32_t*, uint32_t*, uint32_t*, uint32_t*);
    using STUB_THUNK = void __stdcall(Windows::Win32::Rpc::MIDL_STUB_MESSAGE*);
    using SERVER_ROUTINE = int32_t __stdcall();
    using RPC_CLIENT_ALLOC = void* __stdcall(size_t);
    using RPC_CLIENT_FREE = void __stdcall(void*);
    using MIDL_ES_ALLOC = void __stdcall(void*, int8_t**, uint32_t*);
    using MIDL_ES_WRITE = void __stdcall(void*, int8_t*, uint32_t);
    using MIDL_ES_READ = void __stdcall(void*, int8_t**, uint32_t*);
#pragma endregion delegates

}
namespace win32::_impl_
{
#pragma region guids
#pragma endregion guids

}
#endif
